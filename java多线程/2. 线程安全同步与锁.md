线程的安全，说具体点就是共享资源的安全问题，程序中体现就是共享变量的安全问题

## 一、先来了解下这三个名词 “内存可见性”、“指令重排序”、“原子性”

1. 内存可见性：即线程对于共享变量的修改对其他线程可见。java有“主内存，”线程有“工作内I存”，共享变量存储在“主内存”中，线程执行操作共享变量时，“工作内存”会存储共享变量的副本

2. 指令重排序：即指令执行的顺序与源码顺序不一定相同，这是编译器、或者CPU作出的优化决策，不过不用担心的是有`as-if-serial` 原则的保证，即当做串行执行，优化前后执行结果一致，如果你是多线程，则需用户自己保证内存可见性、原子性的问题
    1. 编译重排序
    2. 指令并行重排序
    3. 内存重排序

3. 原子性：即原子不可拆分
如有`i++`，其实这句代码分为三个操作：1. 取i值; 2. 计算i+1； 3. 回写i值。 如果进入执行时i值为1，那么我们想得到的结果是2，但是如果线程执行指令1后，其他的线程修改了i，那么结果将得到错误的结果。相当于是`指令1`到`指令2`之间被拆分了，本线程得到错误的结果；如果`指令2`到`指令3`之间被拆分，那么本线程结果可能正确，但是其他线程将发生错误，当然如果2个指令间隙都被拆分了那么线程们的执行结果将是混乱的。


jvm原生提供可以保证可见性的关键字有：
* synchronized 取锁进入临界区、释放锁退出临界区都会同步工作内存与主内存，所以可见性是得到了保证的
* volatile 保证可见性，工作内存、主内存同步，防止指令重排序。 应用：变量不依赖上次值，例如 i++ 不符合; isStop = false 像这种直接的布尔值就可行
另外`final`修饰变量，变量本身是不可变的，所以就没有列上去了。

## 二、synchronized
`synchronized`表示指定的代码块只能串行执行，同时不可有多个线程在其内部。

`synchronized`可以在任意对象上上锁，如Class、this、String... 等，语法上有三种用法：
* 修饰普通方法
* 修饰静态方法
* 修饰代码块

#### synchronized 的实现原理
通过`javap -verbose xx.class`可以看出`synchronized`代码块在字节码中由：`monitorenter`、`monitorexit`实现，`synchronized`方法由flags`ACC_SYNCHRONIZED`来实现。

对象在内存中的布局分为三块区域：对象头、实例数据、对齐补充，其中对象头中包括锁状态标识等信息，具体可以看[此图](http://naotu.baidu.com/file/745bd47a5fa5990d78050a6d24d84301?token=c5e19fc8520cacfd)

#### synchronized 特点
* 可重入
* 异常后自动释放
* 修饰的同步方法不具继承性

## 三、Lock
`Lock` 接口主要定义了 `lock()/tryLock()`、`unlock()`、`newCondition()`这些方法，其实现类主要有`ReentrantLock`、`ReentrantReadWriteLock.WriteLock`，相比